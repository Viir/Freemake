module GameWorld exposing (FromPlayerInput, Location(..), Node, State, init, updateForPlayerInput, viewLocationSpecific, viewWorld)

import Common
import Dict
import Direction2d
import Html
import Html.Attributes as HA
import Html.Events.Extra.Pointer as Pointer
import LineSegment2d exposing (LineSegment2d)
import MapRawXml
import ParseSvg exposing (VisualPolygon)
import Parser
import Parser.Advanced
import Point2d exposing (Point2d)
import Regex
import Result.Extra
import Set
import Svg
import Svg.Attributes as SA
import Tuple2
import Vector2d
import Visuals
import XmlParser


type Location
    = OnNode NodeId


type alias NodeId =
    Int


type alias Node =
    { visualLocation : Point2d
    , properties : List LocalProperty
    }


type LocalProperty
    = PlayerStart
    | MentoranCaveEntrance
    | MentoranCaveExit


type alias ActionOfferedToUser =
    { context : String
    , triggerLabel : String
    , effect : State -> State
    }


type alias State =
    { playerLocation : Location
    , nodes : Dict.Dict NodeId Node
    , edges : Set.Set EdgeDirection
    , visuals : GameWorldVisuals
    }


type alias EdgeDirection =
    ( NodeId, NodeId )


type FromPlayerInput
    = MoveToNode NodeId
    | ActLocal String


type alias EdgeDerivedProperties =
    { lineSegmentBetweenNodes : LineSegment2d
    }


type alias GameWorldVisuals =
    { polygons : List VisualPolygon
    }


offeredCoursesOfActionForLocalProperty : LocalProperty -> List ActionOfferedToUser
offeredCoursesOfActionForLocalProperty localProperty =
    case localProperty of
        PlayerStart ->
            []

        MentoranCaveEntrance ->
            [ { context = "On a rock face, you see a particularly dark shadow. It looks like a hole in the rock."
              , triggerLabel = "Enter the hole"
              , effect = movePlayerToNodeContainingProperty MentoranCaveExit
              }
            ]

        MentoranCaveExit ->
            [ { context = "There is an opening into a narrow passage. Bright light is coming from the other side."
              , triggerLabel = "Step into the light"
              , effect = movePlayerToNodeContainingProperty MentoranCaveEntrance
              }
            ]


initNodes : Dict.Dict NodeId Node
initNodes =
    initMap
        |> Result.map .nodes
        |> Result.withDefault []
        |> List.indexedMap (\i node -> ( i, node ))
        |> Dict.fromList


edgesToConnectAllNodes : Dict.Dict NodeId Node -> Set.Set EdgeDirection
edgesToConnectAllNodes nodes =
    nodes
        |> Dict.keys
        |> List.concatMap (\orig -> nodes |> Dict.keys |> List.map (\dest -> ( orig, dest )))
        |> List.filter (\( orig, dest ) -> orig /= dest)
        |> Set.fromList


shouldKeepAutogeneratedEdge : EdgeDerivedProperties -> Bool
shouldKeepAutogeneratedEdge properties =
    (properties.lineSegmentBetweenNodes |> LineSegment2d.length) < 160


initEdges : Dict.Dict NodeId Node -> Set.Set EdgeDirection
initEdges nodes =
    nodes
        |> edgesToConnectAllNodes
        |> Set.filter (getEdgeDerivedProperties nodes >> Maybe.map shouldKeepAutogeneratedEdge >> Maybe.withDefault False)
        |> removeLongerIntersectingEdges nodes


init : State
init =
    { playerLocation = OnNode (initNodes |> Dict.keys |> List.head |> Maybe.withDefault 0)
    , nodes = initNodes
    , edges = initEdges initNodes
    , visuals = initMap |> Result.map .visuals |> Result.withDefault { polygons = [] }
    }
        |> movePlayerToNodeContainingProperty PlayerStart


updateForPlayerInput : FromPlayerInput -> State -> State
updateForPlayerInput playerInput stateBefore =
    case playerInput of
        MoveToNode destNodeId ->
            case stateBefore.playerLocation of
                OnNode beforeLocationNodeId ->
                    if stateBefore.edges |> Set.member ( beforeLocationNodeId, destNodeId ) then
                        { stateBefore | playerLocation = OnNode destNodeId }

                    else
                        stateBefore

        ActLocal triggerLabel ->
            (stateBefore
                |> localActionsToOffer
                |> List.filter (.triggerLabel >> (==) triggerLabel)
                |> List.head
                |> Maybe.map .effect
                |> Maybe.withDefault identity
            )
            <|
                stateBefore


playerLocationNode : State -> Maybe Node
playerLocationNode state =
    case state.playerLocation of
        OnNode nodeId ->
            state.nodes |> Dict.get nodeId


localActionsToOffer : State -> List ActionOfferedToUser
localActionsToOffer state =
    state
        |> playerLocationNode
        |> Maybe.map (.properties >> List.concatMap offeredCoursesOfActionForLocalProperty)
        |> Maybe.withDefault []


movePlayerToNodeContainingProperty : LocalProperty -> State -> State
movePlayerToNodeContainingProperty destProperty stateBefore =
    let
        newPlayerLocation =
            stateBefore.nodes
                |> Dict.toList
                |> List.filter (Tuple.second >> .properties >> List.member destProperty)
                |> List.map Tuple.first
                |> List.head
                |> Maybe.map OnNode
    in
    { stateBefore | playerLocation = newPlayerLocation |> Maybe.withDefault stateBefore.playerLocation }


viewWorld : State -> Svg.Svg FromPlayerInput
viewWorld state =
    let
        nodesView =
            state.nodes |> Dict.toList |> List.map (viewNode state) |> Svg.g []

        edgesView =
            state.edges |> Set.toList |> List.map (viewEdge state) |> Svg.g [ SA.opacity "0.3" ]
    in
    [ state.visuals |> viewVisuals
    , edgesView
    , nodesView
    ]
        |> Svg.g []


viewActionOffer : ActionOfferedToUser -> Html.Html FromPlayerInput
viewActionOffer interaction =
    let
        context =
            if 0 < (interaction.context |> String.length) then
                [ interaction.context |> Html.text ] |> Html.div []

            else
                Html.text ""

        trigger =
            [ interaction.triggerLabel |> Html.text ]
                |> Visuals.button [ HA.style "margin" "4px", Pointer.onDown (always (ActLocal interaction.triggerLabel)) ]
    in
    [ context, trigger ] |> Html.div []


viewLocationSpecific : State -> Html.Html FromPlayerInput
viewLocationSpecific state =
    state
        |> localActionsToOffer
        |> List.map viewActionOffer
        |> Html.div []


edgeViewWidth : Float
edgeViewWidth =
    2


nodeViewRadius : Float
nodeViewRadius =
    6


playerLocationIndicatorRadiusBase : Float
playerLocationIndicatorRadiusBase =
    nodeViewRadius * 0.4


viewEdge : State -> EdgeDirection -> Svg.Svg event
viewEdge worldState edge =
    case getEdgeDerivedProperties worldState.nodes edge of
        Just edgeDerivedProperties ->
            case edgeDerivedProperties.lineSegmentBetweenNodes |> edgeVisualLineSegmentFromLineSegmentBetweenNodes of
                Nothing ->
                    Html.text ""

                Just visualLineSegment ->
                    Visuals.svgLineSegmentWithStroke ( "lightgrey", edgeViewWidth ) visualLineSegment

        Nothing ->
            Html.text ""


edgeVisualLineSegmentFromLineSegmentBetweenNodes : LineSegment2d -> Maybe LineSegment2d
edgeVisualLineSegmentFromLineSegmentBetweenNodes lineSegmentBetweenNodes =
    case lineSegmentBetweenNodes |> LineSegment2d.direction of
        Nothing ->
            Nothing

        Just direction ->
            let
                edgeVisualOffset =
                    direction |> Direction2d.rotateBy (pi / 2) |> Vector2d.withLength edgeViewWidth

                visualLength =
                    (lineSegmentBetweenNodes |> LineSegment2d.length) - (nodeViewRadius * 3)

                scaleFactor =
                    visualLength / (lineSegmentBetweenNodes |> LineSegment2d.length)
            in
            lineSegmentBetweenNodes
                |> LineSegment2d.scaleAbout (lineSegmentBetweenNodes |> LineSegment2d.midpoint) scaleFactor
                |> LineSegment2d.mapEndpoints (Point2d.translateBy edgeVisualOffset)
                |> Just


viewNode : State -> ( NodeId, Node ) -> Svg.Svg FromPlayerInput
viewNode worldState ( nodeId, node ) =
    let
        isPlayerLocatedHere =
            worldState.playerLocation == OnNode nodeId

        pointerDownEvent =
            MoveToNode nodeId

        worldAfterPointerDownEvent =
            worldState |> updateForPlayerInput pointerDownEvent

        indicateEffectForInput =
            worldAfterPointerDownEvent.playerLocation /= worldState.playerLocation

        canPlayerGetHereDirectly =
            worldAfterPointerDownEvent.playerLocation == OnNode nodeId

        nodeBaseView =
            svgCircleFromRadiusAndFillAndStroke ( nodeViewRadius, "grey" ) Nothing

        playerView =
            if isPlayerLocatedHere then
                svgCircleFromRadiusAndFillAndStroke ( playerLocationIndicatorRadiusBase, "black" ) Nothing

            else if canPlayerGetHereDirectly then
                playerCanGetHereDirectlyIndication

            else
                Html.text ""

        opacity =
            if isPlayerLocatedHere then
                1

            else if canPlayerGetHereDirectly then
                0.7

            else
                0.4

        transformAttribute =
            SA.transform (node.visualLocation |> Point2d.coordinates |> Visuals.svgTransformTranslate)

        inputAttributes =
            [ Pointer.onDown (always pointerDownEvent) ]
                ++ (if indicateEffectForInput then
                        [ HA.style "cursor" "pointer" ]

                    else
                        []
                   )

        additionalInputArea =
            svgCircleFromRadiusAndFillAndStroke ( nodeViewRadius * 4, "transparent" ) Nothing
    in
    [ additionalInputArea, nodeBaseView, playerView ]
        |> Svg.g (inputAttributes ++ [ transformAttribute, SA.opacity (opacity |> String.fromFloat) ])


viewVisuals : GameWorldVisuals -> Svg.Svg event
viewVisuals visuals =
    visuals.polygons
        |> List.map viewPolygon
        |> Svg.g []


viewPolygon : VisualPolygon -> Svg.Svg event
viewPolygon visualPolygon =
    let
        pathData =
            Visuals.svgPathDataFromPolylineListPoint Visuals.MoveTo visualPolygon.points

        attributes =
            [ ( "d", Just pathData )
            , ( "fill", visualPolygon.fill )
            , ( "fill-opacity", visualPolygon.fillOpacity )
            , ( "stroke", visualPolygon.stroke )
            , ( "stroke-width", visualPolygon.strokeWidth )
            ]
                |> List.filterMap
                    (\( attributeName, maybeAttributeValue ) ->
                        maybeAttributeValue
                            |> Maybe.map (\attributeValue -> HA.attribute attributeName attributeValue)
                    )
    in
    Svg.path attributes []


getEdgeDerivedProperties : Dict.Dict NodeId Node -> EdgeDirection -> Maybe EdgeDerivedProperties
getEdgeDerivedProperties nodes ( origNodeId, destNodeId ) =
    let
        visualLocationFromNodeId nodeId =
            nodes |> Dict.get nodeId |> Maybe.map .visualLocation
    in
    case ( visualLocationFromNodeId origNodeId, visualLocationFromNodeId destNodeId ) of
        ( Just origLocation, Just destLocation ) ->
            Just { lineSegmentBetweenNodes = LineSegment2d.fromEndpoints ( origLocation, destLocation ) }

        _ ->
            Nothing


playerCanGetHereDirectlyIndication : Svg.Svg event
playerCanGetHereDirectlyIndication =
    svgCircleFromRadiusAndFillAndStroke
        ( playerLocationIndicatorRadiusBase, "none" )
        (Just ( playerLocationIndicatorRadiusBase / 4, "black" ))


svgCircleFromRadiusAndFillAndStroke : ( Float, String ) -> Maybe ( Float, String ) -> Svg.Svg event
svgCircleFromRadiusAndFillAndStroke ( radius, fill ) maybeStrokeWidthAndColor =
    let
        strokeAttributes =
            maybeStrokeWidthAndColor
                |> Maybe.map (\( strokeWidth, strokeColor ) -> [ SA.stroke strokeColor, SA.strokeWidth (strokeWidth |> String.fromFloat) ])
                |> Maybe.withDefault []
    in
    Svg.circle ([ SA.r (radius |> String.fromFloat), SA.fill fill ] ++ strokeAttributes) []


initMap : Result (List (Parser.Advanced.DeadEnd String Parser.Problem)) { nodes : List Node, visuals : GameWorldVisuals }
initMap =
    MapRawXml.xml |> XmlParser.parse |> Result.map parseMapXml


parseMapXml : XmlParser.Xml -> { nodes : List Node, visuals : GameWorldVisuals }
parseMapXml mapXml =
    let
        allXmlElements =
            mapXml.root |> ParseSvg.xmlListSelfAndDescendantsNodesDepthFirst |> List.filterMap ParseSvg.xmlNodeAsElement

        accessNodesLocations =
            allXmlElements
                |> List.filter ParseSvg.xmlElementIsCircle
                |> List.filterMap ParseSvg.getCircleLocation

        parsePathsResults =
            allXmlElements
                |> List.filter (\element -> element.tag == "path")
                |> List.map ParseSvg.getVisualPolygonFromXmlElement

        textsWithLocation =
            allXmlElements
                |> List.filterMap ParseSvg.parseSvgTextWithLocation

        placesWithLocationsMappedToNodeLocations =
            textsWithLocation
                |> List.filterMap
                    (\( text, textLocation ) ->
                        case text |> parseLocalPropertyFromText of
                            Err _ ->
                                Nothing

                            Ok place ->
                                case accessNodesLocations |> List.sortBy (textLocation |> Point2d.distanceFrom) |> List.head of
                                    Nothing ->
                                        Nothing

                                    Just nodeLocation ->
                                        Just ( nodeLocation, place )
                    )

        nodes : List Node
        nodes =
            accessNodesLocations
                |> List.map
                    (\nodeLocation ->
                        let
                            nodeProperties =
                                placesWithLocationsMappedToNodeLocations
                                    |> List.filter (Tuple.first >> (==) nodeLocation)
                                    |> List.map Tuple.second
                        in
                        { visualLocation = nodeLocation, properties = nodeProperties }
                    )

        polygons =
            Debug.log "parsePathsResults" (parsePathsResults |> Result.Extra.combine)
                |> Result.withDefault []
    in
    { nodes = nodes, visuals = { polygons = polygons } }


placePropertyFromIdInMapFile : Dict.Dict String LocalProperty
placePropertyFromIdInMapFile =
    [ ( "player-start", PlayerStart )
    , ( "mentoran-cave-entrance", MentoranCaveEntrance )
    , ( "mentoran-cave-exit", MentoranCaveExit )
    ]
        |> Dict.fromList


parseLocalPropertyFromText : String -> Result String LocalProperty
parseLocalPropertyFromText text =
    case Regex.find ("^place\\:\\s*([^\\s]+\\s*)$" |> Regex.fromString |> Maybe.withDefault Regex.never) text of
        [ placeMatch ] ->
            case placeMatch.submatches |> List.head of
                Just (Just placeId) ->
                    case placePropertyFromIdInMapFile |> Dict.get placeId of
                        Nothing ->
                            Err ("Unknown place id: " ++ placeId)

                        Just place ->
                            Ok place

                _ ->
                    Err "Pattern error."

        _ ->
            Err ("Text did not match place pattern: " ++ text)


removeLongerIntersectingEdges : Dict.Dict NodeId Node -> Set.Set EdgeDirection -> Set.Set EdgeDirection
removeLongerIntersectingEdges nodes edges =
    let
        lineSegmentFromEdge edge =
            getEdgeDerivedProperties nodes edge |> Maybe.map .lineSegmentBetweenNodes

        shortenLineSegment origLineSegment =
            origLineSegment |> LineSegment2d.scaleAbout (origLineSegment |> LineSegment2d.midpoint) 0.99

        areEdgesIntersecting edgeA edgeB =
            if edgeA == edgeB || (edgeA |> Tuple2.swap) == edgeB then
                False

            else
                case ( edgeA, edgeB ) |> Common.tuple2MapAll (lineSegmentFromEdge >> Maybe.map shortenLineSegment) of
                    ( Just edgeALineSegment, Just edgeBLineSegment ) ->
                        LineSegment2d.intersectionPoint edgeALineSegment edgeBLineSegment /= Nothing

                    _ ->
                        False

        dictPriorityFromEdgeDirection : Dict.Dict EdgeDirection Int
        dictPriorityFromEdgeDirection =
            edges
                |> Set.toList
                |> List.sortBy (lineSegmentFromEdge >> Maybe.map LineSegment2d.length >> Maybe.withDefault 9999999)
                |> List.indexedMap (\i edgeDirection -> ( edgeDirection, -i ))
                |> Dict.fromList

        priorityFromEdgeDirection edgeDirection =
            dictPriorityFromEdgeDirection |> Dict.get edgeDirection |> Maybe.withDefault -1
    in
    edges
        |> Set.filter
            (\edgeDirection ->
                let
                    edgePrio =
                        priorityFromEdgeDirection edgeDirection

                    intersectingEdges =
                        edges
                            |> Set.filter (\otherEdgeDirection -> areEdgesIntersecting edgeDirection otherEdgeDirection)
                            |> Set.toList

                    intersectingEdgesPriorities =
                        intersectingEdges |> List.map priorityFromEdgeDirection
                in
                intersectingEdgesPriorities
                    |> List.any (\intersectingPrio -> edgePrio <= intersectingPrio)
                    |> not
            )
